// Set global module variables.
export const moduleKey = 'alienrpg-starterset'; // Module name. Important that this one is the exact same as the name of the module
const moduleTitle = 'Alien RPG Starter Set'; // Module Title, is not referenced beyond giving a title to HTML dialog, so can be anything
const packageManifest = 'manifest.json'; // This is the manifest generated by the export script. Not necessary to alter unless the filename has been manually altered.
const sceneToActivate = 'Core Rules Cover'; // The name of the scene you want to display after import.
const welcomeJournalEntry = 'STARTER SET - HOW TO USE THIS MODULE'; // The name of a journal entry you want to display after import.
const moduleFlag = 'alienrpg-sscontent'; // The module specific flag given in the export script
const requiredSystemVersion = '2.0.0';
export const moduleVersion = '2.0.4';

// Added a new type of 'skipimport' so if you do not want to have a particular pack imprted just include it in the list using 'PACK NAME': 'skipimport',
// This is for the use case where you link directly to assets in the compendium so do not want to imrt the contents.
// but all packs must be inclued in moduleFolderNameDict.

const moduleFolderNameDict = {
  'Alien RPG Mother Aids': 'Alien RPG Mother Aids',
  'Alien RPG Armor': 'Alien RPG Armor',
  'Alien RPG Equipment': 'Alien RPG Equipment',
  'Alien RPG Weapons': 'Alien RPG Weapons',
  'Alien RPG Vehicle Weapons': 'Alien RPG Vehicle Weapons',
  'Alien RPG Talents(Career)': 'Alien RPG Talents(Career)',
  'The Art of Alien': 'The Art of Alien',
  'Alien Tables': 'Alien Tables',
  'Alien RPG CotG - Agendas': 'Alien RPG CotG - Agendas',
  'Chariot Of the Gods - Scenario': 'Chariot Of the Gods - Scenario',
  'Chariot of the Gods - Actors': 'Chariot of the Gods - Actors',
  'Alien RPG Chariot of the Gods - Maps': 'Alien RPG Chariot of the Gods - Maps',
  'Alien RPG Starter Set Rules': 'Alien RPG Starter Set Rules',
  'Alien RPG Sub-Entries': 'skipimport',
};

// if (is07x) {
// This object is intended to be used to convert the module pack names back to "Folder names".
// It is referenced against the manifest.json so it is important that the key is the pack name and the value is the folder name.
/**
 * @description This class is responsible for presenting a Dialog that prompts for importing the content of the modules.
 * @extends Dialog A FormApplication class in Foundry VTT responsible for creating pop-up dialogues.
 */
export class ModuleImportDialog extends Dialog {
  constructor() {
    super({
      title: `Import ${moduleTitle}`,
      content: ` <p><b>Initialize Alien RPG Starter Set Module?</b><br><br>
        This will import all Journals and Scenes into your world and organise them into folders</p>
    <ul>
    <li>73 Journal Entries (Starter Set Rules and Chariot of the Gods)</li>
    <li>Including Index journals for the GM and Scenario</li>
    <li>108 item Entries (Armor, Weapons, Equipment, Talents(Career) and CotG Agendas)</li>
    <li>24 Actor Entries (Creatures, PC's and NPC's)</li>
    <li>8 Rolltables (Creature Attacks and GM tables)</li>
    <li>10 Scenes - GM Aids and Chariot of the Gods</li>
    <li>Intergrated Skill-Stunt narative</li>
  </ul>
    <p>
        No part of this publication may be reproduced, distributed, stored in a retrieval system, or transmitted in any form by any means, electronic, mechanical, photocopying, recording or otherwise without the prior permission of the publishers.<br><br>
    
        <sup>tm</sup> & Â© 2021 20th Century Studios Inc. All Rights Reserved<br><br>
    
        <br>
        Published by: <b>Free League Publishing</b><br>
        Foundry Visualisation by <b>Paul Watson</b><br>
        Thanks for their help and support to:<br><b>Thomas Boulton and Frank Graeff</b><br><br>
    
        <a href="https://frialigan.se/">Free League</a>
        <br><br>
        <img src="modules/alienrpg-starterset/images/icons/fl-20cf-logo.png" height=189 width=289 />`,
      buttons: {
        initialize: {
          label: 'Import',
          callback: async () => {
            await this.checkVersion().catch(() => {
              throw console.warn('Version check failed.');
            });
            await new ModuleImportDialog().prepareModule().catch((e) => {
              let error = console.error('Failed to initialize module', e);
              throw error;
            });
            await this.renderWelcome();
            game.settings.set(moduleKey, 'imported', true);
            ui.notifications.notify('Import complete. No Issues.');
          },
        },
        cancel: {
          label: 'Cancel',
          callback: () => {
            game.settings.set(moduleKey, 'imported', true);
            ui.notifications.notify("Canceled importing content. You can always import the compendiums through the Module's settings menu.");
          },
        },
      },
    });
    this.imported = {
      Actor: {},
      Item: {},
      JournalEntry: {},
      RollTable: {},
      Scene: {},
    };
  }
  async prepareModule() {
    const manifest = await this.readManifest(packageManifest);
    const modulePacks = await game.modules.get(moduleKey).packs;
    console.warn('Starting import of: ', moduleTitle);
    ui.notifications.notify('Starting import of: ' + moduleTitle + '. Hold on, this could take a while...');
    await this.importModule(manifest, modulePacks, moduleFolderNameDict);
    await this.performFlagUpdates();
  }

  async importModule(manifest, modulePacks, moduleFolderNameDict) {
    return Promise.all(
      modulePacks.map(async (p) => {
        let moduleFolderId = '';
        let type = '';
        const pack = await game.packs.get(moduleKey + '.' + p.name).getDocuments();

        if (isNewerVersion(game.version,"0.8.9")){
          type = p.type;
        } else {
          type = p.entity;
        }

        if (type !== 'Playlist' && type !== 'Macro') {
          const moduleFolderName = moduleFolderNameDict[p.label];
          if (moduleFolderName === 'skipimport') {
            return;
          }
          if (game.folders.getName(moduleFolderName)) {
            moduleFolderId = game.folders.getName(moduleFolderName);
          } else {
            moduleFolderId = await Folder.create({
              name: moduleFolderName,
              type: type,
              parent: null,
              color: manifest[type][moduleFolderName].color || null,
              sort: manifest[type][moduleFolderName].sort || null,
              sorting: manifest[type][moduleFolderName].sorting || 'a',
            });
          }
          // debugger;
          const manifestEntity = manifest[type][moduleFolderName].content;
          // for (let x in manifestEntity) {
          //   if (game.folders.getName(x)) {
          //     delete manifestEntity[x];
          //   }
          // }
          await this.importFromManifest(manifestEntity, pack, type, moduleFolderId.data._id);
        } else if (type === 'Playlist') {
          const uniquePlaylists = pack.filter((p) => {
            if (!game.playlists.find((n) => n.data.name === p.data.name)) return p;
          });
          Playlist.create(uniquePlaylists.map((p) => p.data));
        } else {
          const uniqueMacros = pack.filter((p) => {
            if (!game.macros.find((n) => n.data.name === p.data.name)) return p;
          });
          Macro.create(uniqueMacros.map((p) => p.data));
        }
        return true;
      })
    );
  }

  async importFromManifest(manifest, pack, type, parent) {
    let folder = ';';
    if (manifest.parent) {
      parent = manifest.parent;
      delete manifest.parent;
    }
    for await (const [key, item] of Object.entries(manifest)) {
      if (key !== 'entities') {
        if (game.folders.getName(key)) {
          folder = game.folders.getName(key);
        } else {
          folder = await Folder.create({
            name: key,
            type: type,
            color: item.color,
            parent: parent || null,
            sort: item.sort || null,
            sorting: item.sorting || 'a',
          });
        }
        const pushParent = Object.values(item);
        await pushParent.forEach((child) => {
          if (child && typeof child === 'object') child.parent = folder.data._id;
        });
        await this.importFromManifest(item.content, pack, type);
      } else if (key === 'entities') {
        try {
          // debugger;
          const entityData = Object.keys(item).reduce((result, identifier) => {
            const entity = pack.filter((e) => e.data._id === identifier);
            return [...result, entity[0].data];
          }, []);

          for (let index = entityData.length - 1; index >= 0; index--) {
            let x = entityData[index];
            let fred = x.document.collectionName;
            let itsMe = x.name;
            if (game[fred].getName(itsMe) != undefined) {
              console.log(x.name, ' Exists', fred);
              delete entityData[index];
            }
          }
          let newentityData = entityData.filter(() => true);

          for await (const entry of newentityData) {
            entry._source.folder = parent || null;
          }

          const cls = getDocumentClass(type);
          const createdEntities = await cls.createDocuments(newentityData, { keepId: true });
          if (Array.isArray(createdEntities)) {
            for await (const entry of createdEntities) {
              this.imported[type][entry.data.name] = entry;
            }
          } else {
            this.imported[type][createdEntities.data.name] = createdEntities;
          }
        } catch (e) {
          console.warn('Could not create entity: ', e);
        }
      } else {
        console.error("I don't understand this key: ", key);
      }
    }
  }
  
  async performFlagUpdates() {
    const entityTypes = ['actors', 'items', 'journal', 'scenes', 'tables'];
    for await (const entityType of entityTypes) {
      switch (entityType) {
        case 'scenes':
          // eslint-disable-next-line no-case-declarations
          const sceneData = [];
          for await (const entity of Object.values(this.imported.Scene)) {
            sceneData.push({
              _id: entity.data._id,
              thumb: entity.data.thumb,
            });
          }
          await Scene.updateDocuments(sceneData);
          break;
        case 'journal':
          // eslint-disable-next-line no-case-declarations
          const journalData = duplicate(Object.values(this.imported.JournalEntry));
          for (const journalEntry of journalData) {
            const flag = journalEntry.data?.flags[moduleFlag]?.folder.sort;
            if (flag) await journalEntry.updateDocuments('sort', flag);
          }
          break;
      }
    }
  }

  // End of 0.8.x code

  async checkVersion() {
    const current = game.system.data.version;
    const required = requiredSystemVersion;
    if (current < required) {
      throw Dialog.prompt({
        title: 'Version Check',
        content: `<h2>Failed to Import</h2><p>Your Alien RPG system version (${current})is below the minimum required version (${required}).</p><p>Please update your system before proceeding.</p>`,
        label: 'Okay!',
        callback: () => ui.notifications.warn('Aborted importing of compendium content. Update your system and try again.'),
      });
    }
  }
  async readManifest(manifestName) {
    const r = await (await fetch(`modules/${moduleKey}/manifests/${manifestName}`))
      .json()
      .catch((e) => console.warn('MANIFEST ERROR: \nYou likely have nothing in your manifest, or it may be improperly formatted.', e));
    return r;
  }

  async hideGMPacks() {
    let pack = ';';
    pack = await game.packs.get('alienrpg-starterset.alienrpg-ss-cotg-actors-actors');
    await pack.configure({ private: true });
    pack = await game.packs.get('alienrpg-starterset.alienrpg-ss-cotg-scenario-journal');
    await pack.configure({ private: true });
    pack = await game.packs.get('alienrpg-starterset.alienrpg-ss-cotg-maps-scenes');
    await pack.configure({ private: true });
    pack = await game.packs.get('alienrpg-starterset.alienrpg-ss-cotg-agendas-items');
    await pack.configure({ private: true });
    console.warn('Hide Packs Completed');
  }

  async renderWelcome() {
    await this.hideGMPacks();

    setTimeout(() => {
      try {
        game.scenes.getName(sceneToActivate).activate();
        // game.journal.getName(welcomeJournalEntry).sheet.render(true, { sheetMode: 'text' });
        Dialog.prompt({
          title: 'Alien RPG Starter Set Importer',
          content: '<p>Welcome to the <strong>Alien RPG Starter Set</strong> <br><br> All assets have been imported.',
          label: 'Okay!',
          callback: () => game.journal.getName('STARTER SET - HOW TO USE THIS MODULE').show(),
        });
      } catch (e) {
        console.error("Couldn't initialize welcome: ", e);
      }
    }, 500);
  }
}
