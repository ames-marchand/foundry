/**
 * @author aMediocreDad
 * @copyright Copyright (c) 2021. You are free to use this software for any purpose without fee or charge.
 *
 * @description:
 *  ***********************************
 *  * This script is intended to be   *
 *  * cut and pasted into the console *
 *  * of foundry                      *
 *  ***********************************
 */

/**
 *
 * @constant
 * @type {Object.<string, string>}
 * @description A dictionary used for referencing the entities you'd like to have exported.
 */
const entityTypes = {
  Actor: 'actors',
  Item: 'items',
  JournalEntry: 'journal',
  RollTable: 'tables',
  Scene: 'scenes',
};

/**
 *
 * 	@param {Object.<string, string>} types is supplied the type-list (usually the one declared above).
 *	@return {Object.<string, unknown>} A nested object of all folders and entities in the world. Folder -> Children -> Content.
 */
async function getDirectories(types) {
  const workingTree = {};
  for (const [typeName, type] of Object.entries(types)) {
    workingTree[typeName] = await game[type].directory.tree;
  }
  return workingTree;
}

/**
 *
 * @description Sets the flags of any entity that you later want to link upon import. E.g. rolltable results, journal entry sorting, or scene notes / tokens.
 */
async function setEntityFlags() {
  for (const [collection, entityType] of Object.entries(entityTypes)) {
    const entityArray = game[entityType].entities;
    for await (entity of entityArray) {
      let dataPath = '';
      switch (entityType) {
        case 'scenes':
          dataPath = entity.data.notes;
          break;
        case 'tables':
          dataPath = entity.data.results;
          break;
        case 'journal':
          await setProperty(entity, 'data.flags.alienrpg-content.folder.sort', entity.data.sort);
          break;
      }
      for (property of dataPath) {
        let flags = '';
        switch (entityType) {
          // Currently scenes only fetches scene notes, but it can also be configured to set token flags or other linked entities
          case 'scenes':
            flags = [
              // to personalize edit the below string to something unique for your module. DO NOT edit "notes.journalEntry" Doing so WILL break import
              'flags.alienrpg-content.notes.journalEntry',
              game.journal.get(property.entryId).data.name,
            ];
            await setProperty(property, ...flags);
            break;
          case 'tables':
            if (property.type >= 1) {
              const typeToGet = entityTypes[property.collection];
              flags = [
                // to personalize edit the below string to something unique for your module.DO NOT edit "results.entityLink". Doing so WILL break import
                'flags.alienrpg-content.results.entityLink',
                {
                  [property.collection]: game[typeToGet].get(property.resultId)?.data.name ?? null,
                },
              ];
              await setProperty(property, ...flags);
            }
            break;
        }
      }
      entityType === 'scenes' || entityType === 'tables' || entityType === 'journal' ? await eval(collection).update(entity, { diff: false }) : null;
    }
  }
}

/**
 *
 * @param {Object.<string, any>} node A node from the object generated by _getDirectories_.
 * @param {Object.<string, string>} manifestEntry A node in the manifest entry. This object is recursively generated by this function.
 * @param {Object.<string, any>} modulePack Foundry object generated in _createdCompendiums_.
 * @param {String} type Foundry Entity type supplied by referencing the _entityTypes_ object.
 * @description This function recurses upon itself by adding content to the Foundry compendium packs, then generating nodes referencing the created content and their **World**.entity_Id in _manifestEntry_.
 */
async function dirtyWork(node, manifestEntry, modulePack, type) {
  for (const [key, entries] of Object.entries(node)) {
    switch (key) {
      case 'content':
        if (entries.length > 0) {
          manifestEntry['entities'] = {};
          const preparedEntries = await Promise.all(entries.map(async (entry) => await entry.toCompendium()));
          const createdEntity = await modulePack.createEntity(preparedEntries);
          if (entries.length === 1) {
            manifestEntry['entities'][createdEntity.data._id] = createdEntity.data.name;
          } else if (entries.length > 1) {
            for await (entry of createdEntity) {
              manifestEntry['entities'][entry.data._id] = entry.data.name;
            }
          } else {
            throw console.error('Failed to add entry to manifest.');
          }
        }
        break;
      case 'children':
        for (let folder of entries) {
          manifestEntry[folder.data.name] = {
            content: {},
            sorting: folder.data.sorting ?? 'a',
            sort: folder.data.sort ?? null,
            color: folder.data.color ?? null,
          };
          await dirtyWork(folder, manifestEntry[folder.data.name].content, modulePack, type);
        }
        break;
    }
  }
}

/**
 *
 * @param {String} moduleLabel Label/Title of a top level folder in a given entity type.
 * @param {String} entityType The entity type, used in generating the name of the compendium.
 * @returns A compendium with a name based on the label and the type (to make sure the same root folder name can be reused across entitytypes).
 */
async function createCompendiums(moduleLabel, entityType) {
  moduleLabel = moduleLabel + ' ' + [entityTypes[entityType]];
  const moduleName = moduleLabel
    .replace(/[^A-z0-9\s]/gi, '')
    .replace(/\s/gi, '-')
    .toLowerCase();
  if (game.packs.get('world.' + moduleName)) {
    console.warn(`Looks like the compendium: ${moduleLabel} already exists. Deleting.`);
    /** Comment out the below code to avoid deleting existing packs. */
    await game.packs.forEach(async (value, key) => {
      key.match(/world/gi) ? await value.delete() : null;
    });
  }
  const createdCompendium = await Compendium.create({
    name: moduleName,
    label: moduleLabel,
    entity: entityType,
  });
  return createdCompendium;
}

/**
 *
 * @param {Array<string>} entityToCheck An array of names of a given entity type.
 * @param {String} type The supplied entity type that matches {@link entityToCheck}.
 * @returns {Function} Console logs OK!
 * @description Looks for duplicates in a given entity type. It is called before the rest of the script runs.
 */
async function truthFinder(entityToCheck, type) {
  const uniqueNames = [...new Set(entityToCheck)];
  if (uniqueNames.length !== entityToCheck.length) {
    const warning = `Found duplicates in ${type}: `;
    let duplicates = [...entityToCheck];
    uniqueNames.forEach((item) => {
      const i = duplicates.indexOf(item);
      duplicates = duplicates.slice(0, i).concat(duplicates.slice(i + 1, duplicates.length));
    });
    throw console.warn(warning, duplicates);
  } else {
    const green = `%c${type.replace(type[0], type[0].toUpperCase())} contain no duplicates.`;
    return console.info(green, 'color:green');
  }
}

/**
 *
 * @description Ties all functions together, looping over each entitytype in workingTree, and finally printing the manifest.json.
 * If you are exporting several "modules" at once you have to split the resulting manifest.json (I intend to do this automatically at some point);
 */
(async function exportModules() {
  Object.values(entityTypes).forEach(async (type) => {
    const entityToCheck = await game[type].entities.map(({ name }) => name);
    await truthFinder(entityToCheck, type).catch((e) => {
      throw console.error('Found duplicates, exiting!', e);
    });
  });
  await setEntityFlags();
  const manifestInitialized = {};
  const workingTree = await getDirectories(entityTypes);
  async function loop() {
    for (let entityType in workingTree) {
      manifestInitialized[entityType] = {};
      const rootDir = workingTree[entityType].children;
      if (rootDir.length !== 0) {
        for (let moduleFolder of rootDir) {
          const moduleFolderName = moduleFolder.data.name;
          const node = moduleFolder;
          manifestInitialized[entityType][moduleFolderName] = {
            content: {},
            sorting: moduleFolder.data.sorting ?? 'a',
            sort: moduleFolder.data.sort ?? null,
            color: moduleFolder.data.color ?? null,
          };
          const manifestEntry = manifestInitialized[entityType][moduleFolderName].content;
          const createdComp = await createCompendiums(moduleFolderName, entityType).catch((e) => {
            error = "Couldn't create compendiums. " + e;
            throw error;
          });
          await dirtyWork(node, manifestEntry, createdComp, entityType);
        }
      }
    }
    return manifestInitialized;
  }
  const finalManifest = await loop().catch((e) => {
    let error = console.error('Looks like something broke:\n', e);
    throw error;
  });
  const print = JSON.stringify(finalManifest);
  saveDataToFile(print, JSON, 'manifest.json');
})();
